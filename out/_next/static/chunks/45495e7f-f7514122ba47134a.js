"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[674],{68795:(e,t,a)=>{a.d(t,{Q6:()=>w}),a(42236);var r=a(51520),n=a(47700),s=a(9706),i=a(83881),o=a(21081),l=a(86632),h=a(64786),u=a(97953),d=a(34726),p=a(71553),g=a(32159),m=a(6843),c=a(44373),f=a(60217),I=a(10874),x=a(77308),E=a(65211),T=a(61560),P=a(26981);let y=r.kernel_impls.whereImpl,D={},L=(0,r.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class w extends r.KernelBackend{nextDataId(){return w.nextDataId++}constructor(e){let t;if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,r.env)().getBool("HAS_WEBGL"))throw Error("WebGL is not supported on this device");if(null!=e){if(e instanceof d.n)t=e;else{let a=(0,n.bU)((0,r.env)().getNumber("WEBGL_VERSION"),e);t=new d.n(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=(0,n.bU)((0,r.env)().getNumber("WEBGL_VERSION"));t=new d.n(e),this.binaryCache=function(e){return e in D||(D[e]={}),D[e]}((0,r.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new I.p(this.gpgpu),this.numMBBeforeWarning=null==(0,r.env)().global.screen?1024:(0,r.env)().global.screen.height*(0,r.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new r.DataStorage(this,(0,r.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,a,r,n,s){let i=this.makeTensorInfo(t,a),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,n]},o.texShape=[r,n];let l=P.FP(t),u=new h.C(l,!1,s),d=this.runWebGLProgram(u,[i],a,[[r,n]]);return d.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),d.dataId}write(e,t,a){if(((0,r.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,r.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===a&&null!=e)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let n={id:this.nextDataId()};return this.texData.set(n,{shape:t,dtype:a,values:e,usage:f.tT.UPLOAD,refCount:1}),n}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,a,n,s){if((0,r.env)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===n)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:a,dtype:n,values:t,usage:f.tT.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t,a,{values:n,dtype:s,complexTensorInfos:i,slice:o,shape:l,isPacked:h}=this.texData.get(e);if(null!=o){let t;t=h?new E.rf(l,x.UC):new x.hE(l,x.UC);let a=this.runWebGLProgram(t,[{dataId:e,shape:l,dtype:s}],s),r=this.readSync(a.dataId);return this.disposeIntermediateTensorInfo(a),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;let u=null!=this.activeTimers;if(u&&(t=r.util.now()),"complex64"===s){let e=this.readSync(i.real.dataId),t=this.readSync(i.imag.dataId);a=r.backend_util.mergeRealAndImagArrays(e,t)}else a=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=r.util.now()-t),this.convertAndCacheOnCPU(e,a)}async read(e){let t,a;if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}let{values:n,shape:s,slice:i,dtype:o,complexTensorInfos:l,isPacked:h}=this.texData.get(e);if(null!=i){let t;t=h?new E.rf(s,x.UC):new x.hE(s,x.UC);let a=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:o}],o),r=this.read(a.dataId);return this.disposeIntermediateTensorInfo(a),r}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,r.env)().getBool("DEBUG")&&!(0,r.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,r.env)().getNumber("WEBGL_VERSION"))throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null;if("complex64"!==o&&(0,r.env)().get("WEBGL_BUFFER_SUPPORTED")){t=this.decode(e);let a=this.texData.get(t.dataId);u=this.gpgpu.createBufferFromTexture(a.texture.texture,...f.GM(s))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){let e=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),t=e[0],n=e[1];a=r.backend_util.mergeRealAndImagArrays(t,n)}else if(null==u)a=this.getValuesFromTexture(e);else{let e=r.util.sizeFromShape(s);a=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=t&&this.disposeIntermediateTensorInfo(t),null!=u){let e=this.gpgpu.gl;P.ul(e,()=>e.deleteBuffer(u))}let d=this.convertAndCacheOnCPU(e,a),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(e=>e(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,r.engine)().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){let{values:a,shape:n,slice:s,dtype:i,isPacked:o,texture:l}=this.texData.get(e);if("complex64"===i)throw Error("Does not support reading texture for complex64 dtype.");if(null!=s){let a;a=o?new E.rf(n,x.UC):new x.hE(n,x.UC);let r=this.runWebGLProgram(a,[{dataId:e,shape:n,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)if(null!=a)throw Error("Data is not on GPU but on CPU.");else throw Error("There is no data on GPU or CPU.");let h=this.decode(e,t.customTexShape);return Object.assign({tensorRef:(0,r.engine)().makeTensorFromTensorInfo(h)},this.texData.get(h.dataId).texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let a=t.map(e=>r.util.decodeString(e));return(0,r.buffer)(e.shape,e.dtype,a)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return(0,r.buffer)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let a=e[t];if(!P.dm(a)){if((0,r.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${a} cannot be represented on this device.`)}}}getValuesFromTexture(e){let{shape:t,dtype:a,isPacked:n}=this.texData.get(e),s=r.util.sizeFromShape(t);if((0,r.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let a=this.decode(e),r=this.texData.get(a.dataId),n=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...f.GM(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(a),n}let i=(0,r.env)().getBool("WEBGL_PACK")&&!0===n,h=i?P.FP(t):t,u=i?new l.N(h):new o.$(h),d=this.runWebGLProgram(u,[{shape:h,dtype:a,dataId:e}],"float32"),p=this.texData.get(d.dataId),g=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(d),g}timerAvailable(){return(0,r.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,a=[],n=!1;null==this.programTimersStack?(this.programTimersStack=a,n=!0):this.activeTimers.push(a),this.activeTimers=a,e();let s=r.util.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=r.util.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,n&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,r.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(s);o.kernelMs=r.util.sum(e),o.getExtraProfileInfo=()=>e.map((e,t)=>({name:i[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,r.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:r.util.now(),endMs:null}}endTimer(e){return(0,r.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.endQuery():e.endMs=r.util.now(),e}async getQueryTime(e){return(0,r.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:a}=this.texData.get(e);return null!=a&&(this.disposeData(a.real.dataId,t),this.disposeData(a.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:a,texShape:r,usage:n,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(t,r,n,s)));let h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=L){return(0,r.env)().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&r.util.sizeFromShape(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){r.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return y(e.shape,t)}packedUnaryOp(e,t,a){let n=new E.rf(e.shape,t),s=this.compileAndRun(n,[e],a);return(0,r.engine)().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=(0,g.f8)(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,r.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,x.pd,e.dtype);let t=new x.hE(e.shape,x.pd),a=this.compileAndRun(t,[e]);return(0,r.engine)().makeTensorFromTensorInfo(a)}makeTensorInfo(e,t,a){let n;if("string"===t&&null!=a&&a.length>0&&r.util.isString(a[0])){let s=a.map(e=>r.util.encodeString(e));n=this.write(s,e,t)}else n=this.write(a,e,t);return this.texData.get(n).usage=null,{dataId:n,shape:e,dtype:t}}makeOutput(e,t,a){return(0,r.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,a),this)}unpackTensor(e){let t=new T.z(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new m.m(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let a=[P.N0(e.shape),...P.Ph(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},n=[P.N0(t),...P.Ph(t)],s=new c.R(n,a),i=this.runWebGLProgram(s,[r],e.dtype,[a],!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){let a,{isPacked:n,shape:o,dtype:l}=this.texData.get(e);if(null!=t){let e=r.util.sizeFromShape(o),a=t[0]*t[1]*4;r.util.assert(e<=a,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let h=P.FP(o);a=n?new i.S(h):new s.K(h);let u=[null!=t?t:f.GM(h)],d=this.runWebGLProgram(a,[{shape:h,dtype:l,dataId:e}],l,u,!0,t);return{dtype:l,shape:o,dataId:d.dataId}}runWebGLProgram(e,t,a,n,s=!1,i){let o,l=this.makeTensorInfo(e.outputShape,a),h=this.texData.get(l.dataId);if(e.packedOutput&&(h.isPacked=!0),e.outPackingScheme===f.BB.DENSE&&(h.texShape=(null!=i?i:f.GM(e.outputShape)).map(e=>2*e)),null!=e.outTexUsage&&(h.usage=e.outTexUsage),0===r.util.sizeFromShape(l.shape))return h.values=r.util.getTypedArrayFromDType(l.dtype,0),l;let u=[],d=t.map(t=>{if("complex64"===t.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let a=this.texData.get(t.dataId);if(null==a.texture){if(!e.packedInputs&&r.util.sizeFromShape(t.shape)<=(0,r.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:a.values};e.packedInputs&&(a.isPacked=!0,a.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!a.isPacked!=!!e.packedInputs)t=a.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),a=this.texData.get(t.dataId);else if(a.isPacked&&!P.P0(a.shape,t.shape)){let e=t,r=t.shape;t.shape=a.shape,t=this.packedReshape(t,r),u.push(t),a=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:a,isUniform:!1}});this.uploadToGPU(l.dataId);let g={shape:l.shape,texData:h,isUniform:!1},m=p.Tb(e,d,g),c=this.getAndSaveBinary(m,()=>p.Kz(this.gpgpu,e,d,g)),I=null!=this.activeTimers;I&&(o=this.startTimer()),(0,r.env)().get("ENGINE_COMPILE_ONLY")||p.mB(this.gpgpu,c,d,g,n),u.forEach(e=>this.disposeIntermediateTensorInfo(e)),I&&(o=this.endTimer(o),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(o)}));let x=(0,r.env)().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){let e=r.util.now();e-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,r.env)().getBool("WEBGL_LAZILY_UNPACK")&&h.isPacked&&!1===s){let e=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),e}return l}compileAndRun(e,t,a,r,n=!1){return a=a||t[0].dtype,this.runWebGLProgram(e,t,a,r,n)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,r.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,r.tidy)(()=>{if(!(0,r.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=(0,r.env)().getBool("DEBUG");(0,r.env)().set("DEBUG",!1);let t=this.abs((0,r.scalar)(1e-8)).dataSync()[0];if((0,r.env)().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t,a=this.texData.get(e),{shape:n,dtype:s,values:i,texture:o,usage:l,isPacked:d}=a;if(null!=o)return;let p=null!=this.activeTimers;p&&(t=r.util.now());let g=a.texShape;if(null==g&&(a.texShape=g=P.fA(n,d)),null!=i){let e,o=P.FP(n),l=g[1],m=g[0],c=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(d||!c)&&([l,m]=f.NO(g[0],g[1])),e=d?new u.A(o,c):new h.C(o,c);let I=c?[m,l]:g,x=this.makeTensorInfo(I,s),E=this.texData.get(x.dataId);c?E.usage=f.tT.PIXELS:E.usage=f.tT.UPLOAD,E.texShape=I,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),l,m,i);let T=[[m,l]],y=this.runWebGLProgram(e,[x],s,T,!0),D=this.texData.get(y.dataId);a.texShape=D.texShape,a.isPacked=D.isPacked,a.usage=D.usage,(0,r.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(a.texture=D.texture,a.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(x),p&&(this.uploadWaitMs+=r.util.now()-t)}else a.texture=this.acquireTexture(g,l,s,d)}convertAndCacheOnCPU(e,t){let a=this.texData.get(e),{dtype:r}=a;return null!=t&&(a.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let a="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<a.length;++t)a[t]=Math.round(e[t]);return a}throw Error(`Unknown dtype ${t}`)}(t,r)),a.values}acquireTexture(e,t,a,r){if(this.numBytesInGPU+=this.computeBytes(e,a),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*r.util.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let a=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}});e.push(a)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await (0,r.nextFrame)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw P.cr(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),Error("Failed to compile fragment shader.");throw Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:a,infLoc:r,nanLoc:n,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=(0,p.Tw)(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=a,e.infLoc=r,e.nanLoc=n,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,a){e.channels=e.channels||"RGBA";let{texture:n,height:s,width:i,channels:o}=e,l=(0,r.engine)().backend;if(!l.gpgpu.gl.isTexture(n))throw Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let h=l.writeTexture(n,t,a,s,i,o);return(0,r.engine)().makeTensorFromDataId(h,t,a,l)}}w.nextDataId=0}}]);